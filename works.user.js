// ==UserScript==
// @name         Works
// @namespace    
// @version      1.1
// @description  Hỗ trợ kiểm tra update works
// @author       Minty
// @match        https://*/user/*/works*
// @match        https://*/truyen/*
// @icon         data:image/x-icon;base64,AAABAAEAQEAAAAEAIAAoQgAAFgAAACgAAABAAAAAgAAAAAEAIAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAADaxiYA2sYmAdrGJnPaxibZ2sYm+9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJvzaxibf2sYmgNrGJgbaxiYA2sYmAtrGJpzaxib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axiaw2sYmCNrGJm3axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJn/axibd2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axibl2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axiT/2cUg/9jDG//Ywxr/2MMZ/9jDGf/Ywxr/2cQd/9rFIv/axiX/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJf/axSL/2cQd/9jDGv/Ywxn/2MMZ/9jDGf/Ywxv/2cQe/9rFI//axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2cUi/9jDGv/Ywxr/28cp/+DORf/l12X/6dx6/+vgh//r4If/6Nt1/+PTVv/dyjT/2cQe/9jDGf/ZxB//2sYm/9rGJv/axib/2sYm/9rGJv/axiT/2cQd/9jDGf/ZxSD/3cs3/+PUWv/o3Hf/6+CH/+vgh//q3oH/5tls/+HRT//cyC7/2cQc/9jDGf/ZxSD/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/ZxSD/2MMa/93LN//n2nL/8eqt//n23P/+/vr//////////////////////////////////Prs//Xvw//r4In/4M9G/9nEHf/ZxB3/2sYm/9rGJP/Ywxr/2sYm/+LTVf/t45L/9vHI//377v//////////////////////////////////////+/jk//PtuP/p3n//381B/9nEHP/ZxB7/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJf/Ywxj/3sw7/+/moP/9++7///////////////////////////////////////////////////////////////////////7++f/z7bf/4dFN/9jCF//axiX/6d16//j01f////////////////////////////////////////////////////////////////////////////799f/y67L/4M9I/9jDGP/axiT/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYn/9nFIf/ZxR//6d19//z77P/////////////////////////////////////////////////////////////////////////////////////////////++//w56T/9/LN//////////////////////////////////////////////////////////////////////////////////////////////////799v/s4Yr/2sYj/9nEH//axif/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYn/9nEH//byCz/8+yz//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Xww//dyzj/2cQc/9rGJ//axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYn/9nEHv/cyS//9/LN//////////////////////////////////////////////////389P/7+OT/+PXX//n12P/8+un////9///////////////////////////////////////////////////////////////////////////////9//z66//59tz/+PTV//r33//8++7/////////////////////////////////////////////////+vji/+HQSf/Zwxv/2sYn/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9nFIP/cyS//9/LN///////////////////////////////////////59tv/7eOS/+PUWv/ezDv/3Mgt/9rGJf/axib/3Mkx/+DQSf/p3Xr/9vHI//////////////////////////////////////////////////799f/z7LX/6Ntz/+DQSf/cyTL/28co/9rGJP/bxyr/3co1/+LSUP/r34X/9/PQ///////////////////////////////////////7+ej/385C/9nEHf/axif/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJP/ZxR//9O68//////////////////////////////////r44v/o23X/28co/9jCGP/ZxBz/2cUh/9rGI//axiX/2sYk/9rFI//ZxB//2MMY/9nFIP/k1V//9vLL/////////////////////////////v76/+/mnv/fzT//2MMb/9jDGf/ZxB//2sUj/9rGJP/axiX/2sYk/9rFIv/ZxB7/2MMY/9rFIv/l1mP/+fXX//////////////////////////////////n12P/byCv/2sUi/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/Ywxj/6t6B//////////////////////////////////Pstv/cyjL/2MMX/9rGJP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axiX/2MMa/9rFIv/r4Ib//fvv////////////+fXY/+LSUf/Ywxf/2cUf/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axiX/2MMZ/9vIKf/w6KX/////////////////////////////////8emr/9jDGv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/ZxSD/380///788/////////////////////////////Hpqf/ZxB7/2cUg/9rGJ//axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axSH/2MMX//bwxf//////9e/A/9zJLf/Zwxv/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axSL/2MMa/+zhiv/////////////////////////////////m2Gf/2cQa/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2MMa//Hpqf////////////////////////////PstP/ZxB7/2sUi/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2MMZ/+3jkv//////9fDE/9rGJv/ZxR//2sYn/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJP/Ywxf/7uSW////////////////////////////+vfh/9vIKv/axiP/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sUh/97MO//+/fX///////////////////////r44f/cyS7/2cUg/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2cQc/+PTVf////7/+/jj/93KMv/ZxB7/2sYn/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYj/9nFHv/178H////////////////////////////p3Xv/2MMZ/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9jDGv/o3Hf////////////////////////////n2m//2MMY/9rGJ//axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYl/9rFIv/388///////+TWYP/Ywxn/2sYn/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/ZxB7/381A//388///////////////////////+PTS/9rFIv/axiX/2sYm/9rGJv/axib/2sYm/9rGJv/ZxBv/8+y2///////////////////////59tv/2sYm/9rGJP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axSP/2cUh/9rFIv/axiX/2sYm/9nEG//m12b///////Pstf/Ywxr/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sUj/9nFIf/ZxSL/2sYl/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9jDF//u5Zr//////////////////////////P/gz0j/2cUf/9rGJv/axib/2sYm/9rGJv/axiT/3Mgs//v45P//////////////////////7eKR/9jDGP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rFI//Ywxv/3Mkv/97MPv/dyzf/2cQf/9nEHv/ZxB3/9e/C///////h0U7/2cQd/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axiP/2MMa/9zILv/ezD7/3cs4/9nEH//ZxB7/2sYn/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/ZxSD/381A//799v//////////////////////6d5+/9jDGf/axib/2sYm/9rGJv/axib/2cQe/+HRTv////7//////////////////////+LSU//ZxB3/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rFIv/bxyj/7uSW//v45P/+/fb//fvv//Tuu//fzkL/3co0///++//38sv/2cQe/9rGJf/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axSL/28cn/+3jlP/7+OP//v32//378P/07r3/4dBK/9nEHP/axif/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9nEHf/28MX///////////////////////Lrs//ZxBv/2sYm/9rGJv/axib/2sYm/9jDGv/o23b///////////////////////z67P/cyjL/2sYj/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJf/axSD/8+23////////////////////////////+/nl/+3jk///////6t5+/9jDGf/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axiX/2cUg//PstP////////////////////////////377//gz0X/2cUf/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/Ywxj/7eKP///////////////////////59tz/28cn/9rGJP/axib/2sYm/9rGJv/Ywxn/7uSZ///////////////////////489D/2sUi/9rGJf/axib/2sYm/9rGJv/axib/2sYm/9rGJv/ZxBv/5tlr///////////////////////////////////////////////8/+HQSf/ZxR//2sYm/9rGJv/axib/2sYm/9rGJv/axib/2cQb/+bYaP//////////////////////////////////////9O69/9nEHf/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2MMb/+bYaf///////////////////////fzz/97MOv/axSH/2sYm/9rGJv/axib/2MMb//LqsP//////////////////////9O26/9jDHP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2cQe//XwxP////////////////////////////////////////////v55v/cyC3/2sYj/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9nEHf/177/////////////////////////////////////////+/P/gz0f/2cUf/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9nEHv/i01T///////////////////////7++//fzkT/2cUg/9rGJv/axib/2sYm/9nEHf/07r////////////////////////Dopv/Ywxn/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sUi/93LNv/9/PH////////////////////////////////////////////38s3/2sUh/9rGJf/axib/2sYm/9rGJv/axib/2sYm/9rFIv/dyjT//fvu////////////////////////////////////////////6dx5/9jDGv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/ZxB7/4tJT///////////////////////+/vr/385D/9nFIP/axib/2sYm/9rGJv/ZxB3/9O6////////////////////////v56H/2MMZ/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9nEHv/i0lD/////////////////////////////////////////////////9O69/9nEHf/axib/2sYm/9rGJv/axib/2sYm/9rGJv/ZxB7/4dFO/////////////////////////////////////////////////+/mnf/Ywxn/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2cQe/+LSU////////////////////////v76/9/OQ//ZxSD/2sYm/9rGJv/axib/2cQd//Tuv///////////////////////7+ei/9jDGf/axib/2sYm/9rGJv/axib/2sYm/9rGJv/ZxBz/5ddl//////////////////////////////////////////////////Ptuf/ZxBz/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2cQc/+XWY//////////////////////////////////////////////////z7LX/2cQb/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9nEHv/i0lP///////////////////////7++v/fzkP/2cUg/9rGJv/axib/2sYm/9nEHf/07r///////////////////////+/nov/Ywxn/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2MMb/+bZa//////////////////////////////////////////////////z7bn/2MQc/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9jDG//n2Gn/////////////////////////////////////////////////9e68/9nEHP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/ZxB7/4tJT///////////////////////+/vr/385D/9nFIP/axib/2sYm/9rGJv/ZxB3/9O6////////////////////////v56L/2MMZ/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9jDG//m2Gr/////////////////////////////////////////////////8+25/9jEHP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/Ywxv/5tdo//////////////////////////////////////////////////Ttu//ZxBz/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2cQe/+LSU////////////////////////v76/9/OQ//ZxSD/2sYm/9rGJv/axib/2cQd//Tuv///////////////////////7+ei/9jDGf/axib/2sYm/9rGJv/axib/2sYm/9rGJv/Ywxv/5thq//////////////////////////////////////////////////Ptuf/YxBz/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2MMb/+bXaP/////////////////////////////////////////////////07bv/2cQc/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9nEHv/i0lP///////////////////////7++v/fzkP/2cUg/9rGJv/axib/2sYm/9nEHf/07r///////////////////////+/nov/Ywxn/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2MMb/+bYav/////////////////////////////////////////////////z7bn/2MQc/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9jDG//m12j/////////////////////////////////////////////////9O27/9nEHP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/ZxB7/4tJT///////////////////////+/vr/385D/9nFIP/axib/2sYm/9rGJv/ZxB3/9O6////////////////////////v56L/2MMZ/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9jDG//m2Gr/////////////////////////////////////////////////8+25/9jEHP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/Ywxv/5tdo//////////////////////////////////////////////////Ttu//ZxBz/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2cQe/+LSU////////////////////////v76/9/OQ//ZxSD/2sYm/9rGJv/axib/2cQd//Tuv///////////////////////7+ei/9jDGf/axib/2sYm/9rGJv/axib/2sYm/9rGJv/Ywxv/5thq//////////////////////////////////////////////////Ptuf/YxBz/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2MMb/+bXaP/////////////////////////////////////////////////07bv/2cQc/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9nEHv/i0lP///////////////////////7++v/fzkP/2cUg/9rGJv/axib/2sYm/9nEHf/07r///////////////////////+/nov/Ywxn/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2MMb/+bYav/////////////////////////////////////////////////z7bn/2MQc/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9jDG//m12j/////////////////////////////////////////////////9O27/9nEHP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/ZxB7/4tJT///////////////////////+/vr/385D/9nFIP/axib/2sYm/9rGJv/ZxB3/9O6////////////////////////v56L/2MMZ/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9jDG//m2Gr/////////////////////////////////////////////////8+25/9jEHP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/Ywxv/5tdo//////////////////////////////////////////////////Ttu//ZxBz/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2cQe/+LSU////////////////////////v76/9/OQ//ZxSD/2sYm/9rGJv/axib/2cQd//Tuv///////////////////////7+ei/9jDGf/axib/2sYm/9rGJv/axib/2sYm/9rGJv/Ywxv/5thq//////////////////////////////////////////////////Ptuf/YxBz/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2MMb/+bXaP/////////////////////////////////////////////////07bv/2cQc/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9nEHv/i0lP///////////////////////7++v/fzkP/2cUg/9rGJv/axib/2sYm/9nEHf/07r///////////////////////+/nov/Ywxn/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2MMb/+bYav/////////////////////////////////////////////////z7bn/2MQc/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9jDG//m12j/////////////////////////////////////////////////9O27/9nEHP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/ZxB7/4tJT///////////////////////+/vr/385D/9nFIP/axib/2sYm/9rGJv/ZxB3/9O6////////////////////////v56L/2MMZ/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9jDG//m2Gr/////////////////////////////////////////////////8+25/9jEHP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/Ywxv/5tdo//////////////////////////////////////////////////Ttu//ZxBz/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2cQe/+LSU////////////////////////v76/9/OQ//ZxSD/2sYm/9rGJv/axib/2cQd//Tuv///////////////////////7+ei/9jDGf/axib/2sYm/9rGJv/axib/2sYm/9rGJv/Ywxv/5thq//////////////////////////////////////////////////Ptuf/YxBz/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2MMb/+bXaP/////////////////////////////////////////////////07bv/2cQc/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9nEHv/i0lP///////////////////////7++v/fzkP/2cUg/9rGJv/axib/2sYm/9nEHf/07r///////////////////////+/nov/Ywxn/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2MMb/+bYav/////////////////////////////////////////////////z7bn/2MQc/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9jDG//m12j/////////////////////////////////////////////////9O27/9nEHP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/ZxB7/4tJT///////////////////////+/vr/385D/9nFIP/axib/2sYm/9rGJv/ZxB3/9O6////////////////////////v56L/2MMZ/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9jDG//m2Gr/////////////////////////////////////////////////8+25/9jEHP/axib/2sYm/9rGJv/axib/2sYm/9rGJv/Ywxv/5tdo//////////////////////////////////////////////////Ttu//ZxBz/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2cQe/+LSU////////////////////////v76/9/OQ//ZxSD/2sYm/9rGJv/axib/2cQd//Tuv///////////////////////7+ei/9jDGP/axiX/2sYl/9rGJf/axiX/2sYl/9rGJf/Ywxr/5thq//////////////////////////////////////////////////Ptuf/YxBv/2sYl/9rGJf/axiX/2sYl/9rGJf/axiX/2MMa/+bXaP/////////////////////////////////////////////////07bv/2cQb/9rGJf/axiX/2sYl/9rGJf/axiX/2sYl/9nEHf/i0lP///////////////////////7++v/fzkP/2cUg/9rGJv/axib/2sYm/9nEHf/078D//////////////////////+/mn//XwRL/2cQf/9nEH//ZxB//2cQf/9nEH//ZxB//18EU/+XXZv/////////////////////////////////////////////////z7bf/18IV/9nEH//ZxB//2cQf/9nEH//ZxB//2cQf/9fBFP/l1mP/////////////////////////////////////////////////9O25/9jCFf/ZxB//2cQf/9nEH//ZxB//2cQf/9nEH//Ywhf/4dFO///////////////////////+/vv/385E/9nFIP/axib/2sYm/9rGJv/ZxBz/8+25///////////////////////7+ej/9fDE//bxyP/28cj/9vHI//bxyP/28cj/9vHI//Xwxf/59dn//////////////////////////////////////////////////Pvt//Xwxf/28cj/9vHI//bxyP/28cj/9vHI//bxyP/18MX/+fXZ//////////////////////////////////////////////////z77v/28MX/9vHI//bxyP/28cj/9vHI//bxyP/28cj/9vDG//j00////////////////////////v73/9/NP//ZxSH/2sYm/9rGJv/axib/2MMZ/+zijf/////////////////////////////////////////////////////////////////////////////////////////////////+/ff//////////////////////////////////////////////////////////////////////////////////////////////////v33//////////////////////////////////////////////////////////////////////////////////////////////////n22//bxib/2sYk/9rGJv/axib/2sYm/9nEHv/i0U/////+////////////////////////////////////////////////////////////////////////////////////////////7eOT//z66////////////////////////////////////////////////////////////////////////////////////////////+7klv/7+eb////////////////////////////////////////////////////////////////////////////////////////////v5pz/2MMa/9rGJv/axib/2sYm/9rGJv/axib/2cQb/+3klf//////////////////////////////////////////////////////////////////////////////////////9fDD/9jDGf/p3Xz///////////////////////////////////////////////////////////////////////////////////////bxyP/ZxBv/6Nt1///////////////////////////////////////////////////////////////////////////////////////59tr/3Mkv/9rFIv/axib/2sYm/9rGJv/axib/2sYm/9rGJP/axSH/6+CJ//378P///////////////////////////////////////////////////////////////////vz/8uqu/9zILv/ZxSD/2cQd/+ncef/8+uz////////////////////////////////////////////////////////////////////9//Lqr//cyS//2cUg/9nEHf/o3Hj//Prr/////////////////////////////////////////////////////////////////////v/07rv/3sw5/9nEHv/axif/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYk/9jDG//ezDv/5thp/+3jkv/u5Jj/7uSY/+7kmP/u5Jj/7uSY/+7kmP/u5Jj/7uSY/+7kl//o3Hj/4M9I/9nEH//axSH/2sYn/9rGJf/Ywxv/3cs3/+XXZ//t45H/7uSY/+7kmP/u5Jj/7uSY/+7kmP/u5Jj/7uSY/+7kmP/u5Jf/6dx6/+DQSv/ZxB//2cUh/9rGJ//axiX/2MMb/93LNv/l12X/7eKQ/+7kmP/u5Jj/7uSY/+7kmP/u5Jj/7uSY/+7kmP/u5Jj/7uSY/+ndfP/h0Ez/2sUi/9nFH//axif/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2cUh/9jDG//Ywxn/2MMZ/9jDGf/Ywxn/2MMZ/9jDGf/Ywxn/2MMZ/9jDGf/Ywxn/2MMa/9nEH//axiX/2sYm/9rGJv/axib/2sYm/9rFIv/Ywxv/2MMZ/9jDGf/Ywxn/2MMZ/9jDGf/Ywxn/2MMZ/9jDGf/Ywxn/2MMZ/9jDGv/ZxB//2sYl/9rGJv/axib/2sYm/9rGJv/axSL/2cQc/9jDGf/Ywxn/2MMZ/9jDGf/Ywxn/2MMZ/9jDGf/Ywxn/2MMZ/9jDGf/Ywxr/2cQf/9rGJf/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv7axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv7axibW2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axibf2sYmX9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYmcdrGJgDaxiaH2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYmnNrGJgPaxiYA2sYmANrGJmHaxibR2sYm+trGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJv/axib/2sYm/9rGJvzaxibX2sYmb9rGJgDaxiYAgAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAwAAAAAAAAAM=
// @run-at       document-idle
// @grant        GM_notification
// @grant        GM_registerMenuCommand
// @grant        GM_xmlhttpRequest
// @grant        GM_openInTab
// @updateURL    https://raw.githubusercontent.com/miinty0/draft/main/works.user.js
// @downloadURL  https://raw.githubusercontent.com/miinty0/draft/main/works.user.js
// @require      https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js
// fork từ script của github.com/BaoBao666888, mình sửa lại theo ý mình (code mình khá ngu + rác nhiều) nên ko muốn làm phiền từ script gốc =)))
// ==/UserScript==

/* global localforage */
(function() {
    'use strict';

    const VERSION = '0.5.4';
    const ALLOWED_HOSTNAMES = ['.net', '.org']
    const FILTER_RESULT_LIMIT = 500;
    const STORE_VERSION = 1;
    const DELAY = 1400;
    const MAX_RETRIES = 10; // Số lần thử lại tối đa
    const RETRY_DELAY = 5000; // Thời gian chờ giữa các lần thử lại (3 giây)
    const STORE_CFG = {
        name: 'wdWorksCache',
        storeName: 'snapshots',
        description: 'Works cache for offline filtering'
    };

    const BROADCAST_PREFIX = 'wdwm:';
    const ORIGIN_ID = Math.random().toString(36).slice(2);
    let broadcastWarned = false;

    const TEXT = {
        needSync: 'Chưa có dữ liệu. Nhấn "Đồng bộ" để tải toàn bộ works.',
        syncRunning: 'Đồng bộ đang chạy, vui lòng đợi…',
        syncDone: 'Đồng bộ hoàn tất. Đừng quên xuất dữ liệu dự phòng.',
        syncAbort: 'Đã dừng đồng bộ theo yêu cầu.',
        exportDone: 'Đã xuất dữ liệu JSON.',
        importDone: 'Nhập dữ liệu thành công.',
        importInvalid: 'File không hợp lệ (sai username/phiên bản).',
        noCache: 'Chưa có dữ liệu để thao tác.',
        manualAdded: 'Đã thêm/cập nhật truyện thủ công.',
        manualRemoved: 'Đã xóa truyện khỏi cache.'
    };

    const state = {
        username: null,
        mode: null,
        basePath: null,
        baseQuery: null,
        key: null,
        cache: null,
        syncing: false,
        abort: false,
        overlay: null,
        panel: null,
        fileInput: null,
        filterModal: null,
        channel: null,
        channelName: null,
        hasInitialFilter: false,
        isPausedByCloudflare: false
    };
    const norm = (text = '') => text.toString().normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase().trim();
    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    const fmtNum = (value) => Number.isFinite(value) ? new Intl.NumberFormat('vi-VN').format(value) : '';
    const fmtDate = (val) => {
        if (!val) return '';
        // val có thể là Date hoặc string (ISO hoặc 'YYYY-MM-DD')
        let d;
        if (val instanceof Date) {
            d = val;
        } else {
            const s = String(val);
            d = new Date(s.includes('T') ? s : `${s}T00:00:00Z`);
        }
        return Number.isNaN(d.getTime()) ? '' : d.toLocaleDateString('vi-VN');
    };
    const fmtDuration = (ms) => {
        if (!ms || ms <= 0) return '';
        const totalSeconds = Math.round(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return minutes ? `${minutes}p ${seconds}s` : `${seconds}s`;
    };
    const parseVNDate = (text) => {
        if (!text) return null;
        const m = text.match(/(\d{2})-(\d{2})-(\d{4})/);
        if (!m) return null;
        return `${m[3]}-${m[2]}-${m[1]}`;
    };
    const parseAbbr = (raw) => {
        if (!raw) return null;
        const upper = raw.trim().toUpperCase();
        const match = upper.match(/([0-9]+(?:\.[0-9]+)?)([KMB]?)/);
        if (!match) {
            const plain = Number(upper.replace(/[^0-9]/g, ''));
            return Number.isNaN(plain) ? null : plain;
        }
        let value = parseFloat(match[1]);
        if (Number.isNaN(value)) return null;
        const suffix = match[2];
        if (suffix === 'K') value *= 1_000;
        else if (suffix === 'M') value *= 1_000_000;
        else if (suffix === 'B') value *= 1_000_000_000;
        return Math.round(value);
    };

    const Http = {
        get: (url) => ({
            html: async () => {
                const res = await fetch(url, {
                    credentials: 'include',
                    headers: { 'X-Requested-With': 'XMLHttpRequest' }
                });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const html = await res.text();
                const doc = new DOMParser().parseFromString(html, 'text/html');
                doc.html = () => html;
                return doc;
            },
        }),
    };

    const Script = {
        execute: (fnStr, fnName, arg) => {
            // Tạo hàm một cách an toàn
            const fn = new Function(fnStr + `; return ${fnName};`)();
            return fn(arg);
        }
    };

    const detectContext = () => {
        const url = new URL(window.location.href);
        url.hash = '';
        const parts = url.pathname.split('/').filter(Boolean);
        const idx = parts.indexOf('user');
        if (idx === -1 || idx + 1 >= parts.length) return null;
        const username = decodeURIComponent(parts[idx + 1]);
        const mode = parts[idx + 2] || 'works';
        const basePath = `/user/${encodeURIComponent(username)}/${mode}`;
        const baseQuery = new URLSearchParams(url.search);
        baseQuery.delete('start');
        return { username, mode, basePath, baseQuery };
    };

    const getCurrentUser = (doc) => {
        // Lấy link trong menu user
        const profileLink = doc.querySelector('nav .nav-wrapper #ddUser a[href^="/user/"]');
        if (profileLink) {
            const href = profileLink.getAttribute('href');
            const parts = href.split('/').filter(Boolean); 
            const slug = parts[1] || '';
            return decodeURIComponent(slug);
        }
        return null;
    };

    const askSyncOptions = () => {
        return new Promise((resolve) => {
            const dialog = document.createElement('div');
            dialog.id = 'wd-works-sync-options';
            dialog.style.cssText = 'position:fixed;inset:0;background:rgba(5,10,15,0.85);display:flex;align-items:center;justify-content:center;z-index:99999;color:#fff;font-family:Segoe UI,sans-serif;';
            dialog.innerHTML = `
            <style>
                .sync-option {
                    border: 1px solid transparent;
                    transition: background-color 0.2s, border-color 0.2s;
                }
                .sync-option:has(input:checked) {
                    background-color: rgba(57, 197, 255, 0.1) !important;
                    border-color: #39c5ff;
                }
            </style>
            <div style="background:#101722;padding:22px;border-radius:14px;min-width:420px;text-align:left;box-shadow:0 16px 36px rgba(0,0,0,.35);">
                <h3 style="margin:0 0 16px;font-size:16px;font-weight:600;">Tùy chọn đồng bộ</h3>
                <div style="display:flex; flex-direction:column; gap:12px; margin-bottom:20px;">
                    <label class="sync-option" style="display:flex; align-items:center; gap:8px; padding:10px; background:rgba(255,255,255,0.05); border-radius:8px; cursor:pointer;">
                        <input type="radio" name="sync-mode" value="full_no_summary" checked style="width:18px; height:18px; accent-color:#39c5ff; pointer-events:none;">
                        <div>
                            <strong style="color:#fff;">Đồng bộ nhanh</strong>
                            <div style="font-size:12px; opacity:0.8;">Quét lại danh sách truyện và thông tin cơ bản. Tốc độ nhanh nhất.</div>
                        </div>
                    </label>
                    <label class="sync-option" style="display:flex; align-items:center; gap:8px; padding:10px; background:rgba(255,255,255,0.05); border-radius:8px; cursor:pointer;">
                        <input type="radio" name="sync-mode" value="full_with_summary" style="width:18px; height:18px; accent-color:#39c5ff; pointer-events:none;">
                        <div>
                            <strong style="color:#fff;">Đồng bộ đầy đủ </strong>
                            <div style="font-size:12px; opacity:0.8;">Quét tất cả thông tin, bao gồm cả tóm tắt. Sẽ mất nhiều thời gian hơn.</div>
                        </div>
                    </label>

                    <label class="sync-option" style="display:flex; align-items:center; gap:8px; padding:10px; background:rgba(255,255,255,0.05); border-radius:8px; cursor:pointer;">
                        <input type="radio" name="sync-mode" value="summary_only" style="width:18px; height:18px; accent-color:#39c5ff; pointer-events:none;">
                        <div>
                            <strong style="color:#fff;">Chỉ đồng bộ tóm tắt</strong>
                            <div style="font-size:12px; opacity:0.8;">Chỉ tải tóm tắt cho các truyện chưa có. Hữu ích khi danh sách truyện đã đủ.</div>
                        </div>
                    </label>

                </div>
                <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top:16px;">
                     <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
                         <div>
                             <label for="sync-threads" style="font-size:12px; opacity:0.8; margin-bottom:4px; display:block;">Số luồng</label>
                             <input id="sync-threads" type="number" value="1" min="1" max="5" style="width:100%; padding: 7px 8px; background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.2); color: #fff; border-radius: 6px; font-size: 13px;">
                         </div>
                         <div>
                             <label for="sync-delay" style="font-size:12px; opacity:0.8; margin-bottom:4px; display:block;">Delay (ms)</label>
                             <input id="sync-delay" type="number" value="1500" min="500" step="100" style="width:100%; padding: 7px 8px; background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.2); color: #fff; border-radius: 6px; font-size: 13px;">
                         </div>
                     </div>
                </div>
                <div class="controls" style="margin-top:20px; text-align:right; display:flex; justify-content:flex-end; gap:10px;">
                     <button data-action="cancel" style="background:rgba(255,255,255,0.12);border:none;color:#fff;padding:6px 14px;border-radius:6px;cursor:pointer;">Hủy</button>
                     <button data-action="start" style="background:#39c5ff;border:none;color:#0b1220;padding:6px 14px;border-radius:6px;cursor:pointer;font-weight:600;">Bắt đầu</button>
                </div>
            </div>`;

            dialog.addEventListener('click', (e) => {
                const button = e.target.closest('button[data-action]');
                const action = button ? button.dataset.action : null;

                const label = e.target.closest('.sync-option');
                if (label) {
                    const radio = label.querySelector('input[type="radio"]');
                    if (radio) {
                        radio.checked = true;
                    }
                }

                if (action === 'cancel') {
                    dialog.remove();
                    resolve(null);
                } else if (action === 'start') {
                    const mode = dialog.querySelector('input[name="sync-mode"]:checked').value;
                    const threads = parseInt(dialog.querySelector('#sync-threads').value, 10) || 1;
                    const delay = parseInt(dialog.querySelector('#sync-delay').value, 10) || 1500;
                    dialog.remove();
                    resolve({ mode, threads, delay });
                }
            });

            document.body.appendChild(dialog);
        });
    };

    const ensureOverlay = () => {
        if (state.overlay) return state.overlay;
        const wrap = document.createElement('div');
        wrap.id = 'wd-works-overlay';
        wrap.style.cssText = 'position:fixed;inset:0;background:rgba(5,10,15,0.78);display:flex;align-items:center;justify-content:center;z-index:99998;color:#fff;font-family:Segoe UI,sans-serif;';
        wrap.innerHTML = `
            <div style="background:#101722;padding:22px;border-radius:14px;min-width:320px;text-align:center;box-shadow:0 16px 36px rgba(0,0,0,.35);">
                <div class="msg" style="font-size:15px;font-weight:600;margin-bottom:12px;">Đang đồng bộ…</div>
                <div class="bar" style="width:100%;height:6px;background:rgba(255,255,255,0.15);border-radius:999px;overflow:hidden;">
                    <span style="display:block;height:100%;width:0;background:linear-gradient(90deg,#39c5ff,#4bffdc);transition:width .2s;"></span>
                </div>
                <div class="meta" style="margin-top:10px;font-size:12px;opacity:.85;"></div>
                <div class="controls" style="margin-top:16px;">
                     <button data-action="stop" style="background:rgba(246,78,96,0.28);border:none;color:#fff;padding:6px 14px;border-radius:6px;cursor:pointer;">Dừng</button>
                     <button data-action="resume" style="display:none; background:#39c5ff;border:none;color:#0b1220;padding:6px 14px;border-radius:6px;cursor:pointer;font-weight:600;">Tiếp tục</button>
                </div>
            </div>`;

        wrap.querySelector('button[data-action="stop"]').addEventListener('click', () => {
            state.abort = true;
            state.isPausedByCloudflare = false;
        });

        wrap.querySelector('button[data-action="resume"]').addEventListener('click', () => {
            state.isPausedByCloudflare = false;

            
            updateOverlay({ text: 'Đang tiếp tục đồng bộ...', meta: 'Đã nhận tín hiệu, tiếp tục quét...' });

            const overlay = ensureOverlay(); 
            overlay.querySelector('.bar').style.display = 'block';
            overlay.querySelector('.controls button[data-action="stop"]').style.display = 'inline-block';
            overlay.querySelector('.controls button[data-action="resume"]').style.display = 'none';
        });

        document.body.appendChild(wrap);
        state.overlay = wrap;
        return wrap;
    };

    const updateOverlay = ({ text, progress, meta }) => {
        const overlay = ensureOverlay();
        const msg = overlay.querySelector('.msg');
        const bar = overlay.querySelector('.bar span');
        const metaEl = overlay.querySelector('.meta');
        if (text) msg.textContent = text;
        if (typeof progress === 'number') bar.style.width = `${Math.min(100, Math.max(0, progress))}%`;
        if (meta !== undefined) metaEl.textContent = meta || '';
    };

    const hideOverlay = () => {
        if (state.overlay) {
            state.overlay.remove();
            state.overlay = null;
        }
    };

    const ensurePanel = () => {
        if (state.panel) return state.panel;
        const panel = document.createElement('div');
        panel.id = 'wd-works-panel';

        panel.style.cssText = 'position:fixed;bottom:80px;right:20px;z-index:99997;background:rgba(17,25,34,0.92);color:#fff;padding:12px 14px;border-radius:10px;min-width:300px;font-family:Segoe UI,sans-serif;font-size:12px;box-shadow:0 12px 30px rgba(0,0,0,0.25);';

        panel.innerHTML = `
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                <strong style="font-size:13px;">Works Manager</strong>
                <button data-action="toggle" style="background:none;border:none;color:#fff;font-size:16px;line-height:1;cursor:pointer;">+</button>
            </div>
            <div class="summary" style="line-height:1.6; display:none;"></div>
            <div class="actions" style="display:none; grid-template-columns: repeat(3, 1fr); gap:6px; margin-top:10px;"></div>
            <div class="msg" style="margin-top:8px;opacity:.8; display:none;"></div>`;

        const actions = [
            ['sync', 'Đồng bộ'],
            ['export', 'Xuất'],
            ['import', 'Nhập'],
            ['filter', 'Lọc'],
            ['add', 'Thêm tay'],
            ['clear', 'Xóa cache']
        ];

        const actionsEl = panel.querySelector('.actions');
        actions.forEach(([action, label]) => {
            const btn = document.createElement('button');
            btn.dataset.action = action;
            btn.textContent = label;

            let specificStyle = 'background:rgba(255,255,255,0.16);';
            if (action === 'clear') specificStyle = 'background:rgba(246,78,96,0.28);';
            if (action === 'sync') specificStyle = 'background:rgba(57, 197, 255, 0.25);'; 

            btn.style.cssText = `width:100%; border:none; color:#fff; padding:8px 4px; border-radius:6px; cursor:pointer; font-size:11px; font-weight:600; ${specificStyle}`;
            actionsEl.appendChild(btn);
        });

        panel.dataset.collapsed = '1';

        panel.addEventListener('click', (event) => {
            const target = event.target.closest('button[data-action]');
            if (!target) return;
            event.stopPropagation();
            const action = target.dataset.action;

            if (action === 'toggle') {
                const isCollapsed = panel.dataset.collapsed === '1';
                panel.dataset.collapsed = isCollapsed ? '0' : '1';
                if (isCollapsed) {
                    panel.querySelector('.summary').style.display = 'flex';
                    panel.querySelector('.actions').style.display = 'grid';
                    panel.querySelector('.msg').style.display = '';
                    target.textContent = '–';
                } else {
                    panel.querySelector('.summary').style.display = 'none';
                    panel.querySelector('.actions').style.display = 'none';
                    panel.querySelector('.msg').style.display = 'none';
                    target.textContent = '+';
                }
                return;
            }

            if (action === 'sync') handleSync();
            else if (action === 'export') handleExport();
            else if (action === 'import') handleImport();
            else if (action === 'filter') openFilter();
            else if (action === 'add') handleManualAdd();
            else if (action === 'clear') handleClear();
        });
        document.body.appendChild(panel);
        state.panel = panel;
        return panel;
    };

    const panelSummary = () => ensurePanel().querySelector('.summary');
    const panelMessage = () => ensurePanel().querySelector('.msg');
    const setMessage = (text) => { panelMessage().textContent = text || ''; };

    const notify = (text, isError = false) => {
        try {
            GM_notification({ title: 'Works Manager', text, timeout: 4000 });
        } catch (_) {
            // ignore
        }
        if (isError) console.warn('[WorksManager]', text);
        else console.log('[WorksManager]', text);
        setMessage(text);
    };

    const ensureFileInput = () => {
        if (state.fileInput) return state.fileInput;
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json';
        input.style.display = 'none';
        input.addEventListener('change', async (event) => {
            const file = event.target.files && event.target.files[0];
            if (!file) return;
            try {
                const json = JSON.parse(await file.text());
                if (!json || json.username !== state.username || json.version !== STORE_VERSION) {
                    notify(TEXT.importInvalid, true);
                    return;
                }
                await saveCache(json);
                notify(TEXT.importDone);
                updateSummary();
            } catch (err) {
                console.error('[WorksManager] import', err);
                notify('Không thể nhập dữ liệu.', true);
            } finally {
                event.target.value = '';
            }
        });
        document.body.appendChild(input);
        state.fileInput = input;
        return input;
    };
    const saveCache = async (data) => {
        await localforage.setItem(state.key, data);
        state.cache = data;
    };

    const loadCache = async () => {
        state.cache = await localforage.getItem(state.key);
    };

    const updateSummary = () => {
        const summary = panelSummary();
        if (!state.cache) {
            summary.innerHTML = TEXT.needSync;
            setMessage('');
            return;
        }
        const total = state.cache.bookIds.length;

        // Dùng thẻ span và style để các thành phần nằm trên một hàng, cách nhau bởi dấu gạch đứng hoặc khoảng trống
        summary.style.display = 'flex';
        summary.style.flexWrap = 'wrap';
        summary.style.gap = '10px';
        summary.style.fontSize = '11px'; 

        summary.innerHTML = `
            <span>Tổng: <strong>${fmtNum(total)}</strong></span>
            <span style="opacity: 0.5;">|</span>
            <span>Cập nhật: <strong>${fmtDate(state.cache.syncedAt)}</strong></span>
            <span style="opacity: 0.5;">|</span>
            <span>ETA: <strong>${fmtDuration(state.cache.durationMs)}</strong></span>
        `;

        const currentTotal = readTotal(document);
        if (currentTotal && currentTotal > total) {
            setMessage(`Có ${fmtNum(currentTotal - total)} truyện mới. Hãy đồng bộ lại!`);
        } else {
            setMessage('');
        }
    };

    const readTotal = (doc) => {
        const node = doc.querySelector('.book-count');
        if (!node) return null;
        const value = Number(node.textContent.replace(/[^0-9]/g, ''));
        return Number.isNaN(value) ? null : value;
    };

    const parseBook = (node) => {
        try {
            const checkbox = node.querySelector('input[name="bookId"]');
            const id = checkbox ? checkbox.value.trim() : null;
            if (!id) return null;
            const titleAnchor = node.querySelector('.book-title');
            const title = titleAnchor ? titleAnchor.textContent.trim() : '';
            const url = titleAnchor ? new URL(titleAnchor.getAttribute('href'), window.location.origin).href : null;
            const cover = node.querySelector('.book-cover img');
            const coverUrl = cover ? new URL(cover.getAttribute('src'), window.location.origin).href : null;
            const authorNodes = node.querySelectorAll('.book-author');
            let author = '';
            let status = '';
            const tags = [];
            authorNodes.forEach((p, index) => {
                const text = p.textContent.trim();
                const href = p.querySelector('a')?.getAttribute('href') || '';
                if (index === 0) author = text;
                else if (href.includes('status=')) status = text;
                else if (text) tags.push(text);
            });
            const stats = {};
            node.querySelectorAll('.book-stats').forEach((span) => {
                const icon = span.querySelector('i');
                const valueNode = span.querySelector('[data-ready]') || span;
                const raw = valueNode.textContent.trim();
                if (!icon) return;
                const iconName = icon.classList.contains('material-icons') ? icon.textContent.trim() : icon.className;
                if (iconName === 'visibility') stats.views = parseAbbr(raw);
                else if (iconName === 'star') stats.rating = parseAbbr(raw);
                else if (iconName.includes('fa-comment')) stats.comments = parseAbbr(raw);
            });
            const extra = node.querySelector('.book-info-extra');
            let chapters = null;
            let updated = null;
            if (extra) {
                const chapter = extra.querySelector('.book-chapter-count');
                if (chapter) {
                    const value = Number(chapter.textContent.replace(/[^0-9]/g, ''));
                    chapters = Number.isNaN(value) ? null : value;
                }
                const lastUpdate = extra.querySelector('.book-last-update');
                if (lastUpdate) updated = parseVNDate(lastUpdate.textContent);
            }
            return {
                id,
                title,
                url,
                coverUrl,
                author,
                status,
                statusNorm: norm(status),
                titleNorm: norm(title),
                authorNorm: norm(author),
                tags,
                stats: {...stats,thanks: 0},
                chapters,
                updated,
                updatedText: updated ? fmtDate(updated) : '',
                collectedAt: new Date().toISOString(),
                collections: [],
                flags: {
                    poster: false,
                    managerOwner: false,
                    managerGuest: false,
                    editorOwner: false,
                    editorGuest: false,
                    private: false,
                    embedLink: false,
                    embedFile: false,
                    duplicate: false,
                    vip: false
                }
            };
        } catch (err) {
            console.error('[WorksManager] parseBook', err);
            return null;
        }
    };
    const extractFromDocument = (doc) => {
        const container = doc.querySelector('.book-list');
        if (!container) return { list: [], total: null, pageSize: 0 };
        const nodes = Array.from(container.querySelectorAll(':scope > .book-info'));
        return {
            list: nodes.map(parseBook).filter(Boolean),
            total: readTotal(doc),
            pageSize: nodes.length
        };
    };

    const fetchDocument = async (start, extraParams = null) => {
        let finalUrl;

        // KIỂM TRA "CHỈ THỊ ĐẶC BIỆT"
        if (extraParams && extraParams.overrideUrl) {
            finalUrl = extraParams.overrideUrl; // Nếu có, dùng trực tiếp URL này
        } else {
            // Nếu không, hoạt động như cũ
            const url = new URL(state.basePath, window.location.origin);
            if (extraParams) {
                Object.entries(extraParams).forEach(([key, value]) => {
                    url.searchParams.set(key, value);
                });
            }
            if (start > 0) url.searchParams.set('start', String(start));
            finalUrl = url.href;
        }


        for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            try {
                // Nếu đang bị tạm dừng, chờ ở đây
                while (state.isPausedByCloudflare) {
                    if (state.abort) throw new Error('Đã dừng đồng bộ theo yêu cầu.');
                    await sleep(500); // Chờ 0.5s rồi kiểm tra lại
                }

                const response = await fetch(finalUrl, { // Dùng finalUrl thay vì url.href
                    credentials: 'include',
                    headers: { 'X-Requested-With': 'XMLHttpRequest' }
                });

                let htmlContent = await response.text();
                const isCloudflareChallenge = response.status === 403 || htmlContent.includes('cdn-cgi/challenge-platform');

                if (isCloudflareChallenge) {
                    console.warn('[WorksManager] Phát hiện Cloudflare. Tạm dừng và chờ người dùng xác nhận.');
                    state.isPausedByCloudflare = true;

                    GM_openInTab(window.location.origin, { active: true });

                    const overlay = ensureOverlay();
                    updateOverlay({
                        text: 'Yêu cầu xác thực',
                        meta: 'Đã mở một tab mới. Vui lòng giải quyết CAPTCHA (nếu có) và chờ trang tải xong. Sau đó, quay lại đây và nhấn "Tiếp tục".'
                    });
                    overlay.querySelector('.bar').style.display = 'none';
                    overlay.querySelector('.controls button[data-action="stop"]').style.display = 'none';
                    overlay.querySelector('.controls button[data-action="resume"]').style.display = 'inline-block';

                    // Chờ vòng lặp tiếp theo kiểm tra lại state.isPausedByCloudflare
                    attempt--; // Không tính đây là một lần thử lại thất bại
                    continue;
                }

                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return new DOMParser().parseFromString(htmlContent, 'text/html');

            } catch (err) {
                if (state.abort) throw err; // Nếu người dùng đã bấm dừng, ném lỗi ra ngay
                console.warn(`[WorksManager] Lỗi khi tải trang (thử lại ${attempt}/${MAX_RETRIES}):`, err.message);
                if (attempt >= MAX_RETRIES) throw err;
                await sleep(RETRY_DELAY);
            }
        }
    };

    const addUnique = (arr, value) => {
        if (!value) return;
        if (!arr.includes(value)) arr.push(value);
    };

    const fetchIdsForTask = async (task) => {
        const ids = new Set();
        let start = 0;
        let total = Infinity;
        let pageSize = null;
        while (start === 0 || start < total) {
            if (state.abort) throw new Error(TEXT.syncAbort);
            const doc = await fetchDocument(start, task.params);
            const data = extractFromDocument(doc);
            data.list.forEach((book) => ids.add(book.id));
            if (data.total !== null && data.total !== undefined) total = data.total;
            pageSize = data.pageSize || pageSize || 10;
            if (!pageSize || pageSize <= 0) break;
            start += pageSize;
            if (start >= total) break;
            await sleep(DELAY);
        }
        return ids;
    };

    const fetchAllBooksForTask = async (task) => {
        const books = [];
        const seenIds = new Set();
        let start = 0;
        let total = Infinity;
        let pageSize = null;
        while (start === 0 || start < total) {
            if (state.abort) throw new Error(TEXT.syncAbort);
            const doc = await fetchDocument(start, task.params);
            const data = extractFromDocument(doc);
            data.list.forEach((book) => {
                if (book && !seenIds.has(book.id)) {
                    books.push(book);
                    seenIds.add(book.id);
                }
            });
            if (data.total !== null && data.total !== undefined) total = data.total;
            pageSize = data.pageSize || pageSize || 10;
            if (!pageSize || pageSize <= 0) break;
            start += pageSize;
            if (start >= total) break;
            await sleep(DELAY);
        }
        return books;
    };

    const handleExport = () => {
        if (!state.cache) {
            notify(TEXT.noCache, true);
            return;
        }
        try {
            const blob = new Blob([JSON.stringify(state.cache, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `wikidich-works-${state.username}-${state.mode}.json`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(url), 4000);
            notify(TEXT.exportDone);
        } catch (err) {
            console.error('[WorksManager] export', err);
            notify('Xuất dữ liệu thất bại.', true);
        }
    };

    const handleImport = () => {
        ensureFileInput().click();
    };

    const handleClear = async () => {
        if (!state.cache) {
            notify(TEXT.noCache, true);
            return;
        }
        if (!window.confirm('Xóa toàn bộ cache works hiện có?')) return;
        await localforage.removeItem(state.key);
        state.cache = null;
        notify('Đã xóa cache.');
        updateSummary();
    };

    const handleManualRemove = async (bookId) => {
        if (!state.cache || !state.cache.books[bookId]) {
            notify('Truyện không tồn tại trong cache.', true);
            return;
        }
        const bookTitle = state.cache.books[bookId].title;
        if (!window.confirm(`Bạn có chắc muốn xóa "${bookTitle}" khỏi cache?`)) return;

        state.cache.bookIds = state.cache.bookIds.filter(id => id !== bookId);
        delete state.cache.books[bookId];

        await saveCache(state.cache);
        notify(TEXT.manualRemoved);
        updateSummary();

        if (state.channel) {
            state.channel.postMessage({ origin: ORIGIN_ID, type: 'remove', bookId: bookId, title: bookTitle });
        }
    };

    const fetchAccurateChapterCount = async (doc, bookId) => {
        try {
            const BASE_URL = window.location.origin;
            const html = doc.documentElement.innerHTML;
            const size = html.match(/loadBookIndex.*?,\s*(\d+)/)?.[1] || 50;
            const signKey = html.match(/signKey\s*=\s*"([^"]+)"/)?.[1];
            const fuzzySign = html.match(/function fuzzySign[\s\S]*?}/)?.[0];

            if (!bookId || !signKey || !fuzzySign) {
                console.warn('[WorksManager] Thiếu thông tin để tải danh sách chương từ API.');
                return null;
            }

            // GIỮ NGUYÊN signFunc gốc, không thay đổi
            const signFunc = `function signFunc(r){function o(r,o){return r>>>o|r<<32-o}for(var f,n,t=Math.pow,c=t(2,32),i="length",a="",e=[],u=8*r[i],v=[],g=[],h=g[i],l={},s=2;64>h;s++)if(!l[s]){for(f=0;313>f;f+=s)l[f]=s;v[h]=t(s,.5)*c|0,g[h++]=t(s,1/3)*c|0}for(r+="";r[i]%64-56;)r+="\\0";for(f=0;f<r[i];f++){if((n=r.charCodeAt(f))>>8)return;e[f>>2]|=n<<(3-f)%4*8}for(e[e[i]]=u/c|0,e[e[i]]=u,n=0;n<e[i];){var d=e.slice(n,n+=16),p=v;for(v=v.slice(0,8),f=0;64>f;f++){var w=d[f-15],A=d[f-2],C=v[0],F=v[4],M=v[7]+(o(F,6)^o(F,11)^o(F,25))+(F&v[5]^~F&v[6])+g[f]+(d[f]=16>f?d[f]:d[f-16]+(o(w,7)^o(w,18)^w>>>3)+d[f-7]+(o(A,17)^o(A,19)^A>>>10)|0);(v=[M+((o(C,2)^o(C,13)^o(C,22))+(C&v[1]^C&v[2]^v[1]&v[2]))|0].concat(v))[4]=v[4]+M|0}for(f=0;8>f;f++)v[f]=v[f]+p[f]|0}for(f=0;8>f;f++)for(n=3;n+1;n--){var S=v[f]>>8*n&255;a+=(16>S?0:"")+S.toString(16)}return a}`;

            const genSign = (signKey, currentPage, size) => {
                return Script.execute(signFunc, "signFunc",
                                      Script.execute(fuzzySign, "fuzzySign", signKey + currentPage + size)
                                     );
            }

            const getChapterInPage = async (currentPage) => {
                const params = new URLSearchParams({
                    bookId: bookId,
                    signKey: signKey,
                    sign: genSign(signKey, currentPage, size),
                    size: size,
                    start: currentPage.toFixed(0)
                });
                console.log(`Link: ${BASE_URL}/book/index?${params}`);
                return await Http.get(`${BASE_URL}/book/index?${params}`).html();
            }

            let totalChapters = 0;
            let currentPage = 0;
            let docPage = await getChapterInPage(currentPage);

            while (docPage) {
                const els = docPage.querySelectorAll("li.chapter-name a");
                totalChapters += els.length;

                const paginationLinks = docPage.querySelectorAll("ul.pagination a[data-start]");
                if (paginationLinks.length === 0) break;

                const lastPageStart = parseInt(paginationLinks[paginationLinks.length - 1].getAttribute("data-start"), 10);
                if (currentPage >= lastPageStart) break;

                currentPage += parseInt(size, 10);
                docPage = await getChapterInPage(currentPage);
            }

            return totalChapters;
        } catch (err) {
            console.error('[WorksManager] Lỗi khi lấy số chương chính xác bằng API:', err);
            return null; // Trả về null nếu có lỗi
        }
    };

    const parseBookFromPage = async (doc, bookId, bookUrl, currentUser) => {
        try {
            const info = doc.querySelector('.cover-info');
            if (!info) throw new Error('Không tìm thấy khối .cover-info');
            console.log('[parseBookFromPage] .cover-info:', info);

            const title = info.querySelector('h2')?.textContent.trim() || '';
            console.log('[parseBookFromPage] title:', title);

            const coverEl = doc.querySelector('.cover-wrapper img');
            const coverUrl = coverEl ? new URL(coverEl.src, window.location.origin).href : null;
            const findP = (keyword) =>
            Array.from(info.querySelectorAll('p')).find(p =>
                                                        norm(p.textContent).replace(/\s+/g, ' ').includes(keyword)
                                                       );
            const findPByXPath = () => {
                try {
                    const xp = './/p[contains(normalize-space(.), "Thời gian đổi mới")]';
                    const ctx = info || doc;
                    const res = (doc.evaluate || document.evaluate).call(
                        doc, xp, ctx, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null
                    );
                    return res.singleNodeValue || null;
                } catch (_) {
                    return null;
                }
            };

            const pTime = findP('thoi gian doi moi') || findPByXPath();
            console.log('[parseBookFromPage] pTime outerHTML:', pTime ? pTime.outerHTML : null);

            const getTextFromP = (p) => {
                if (!p) return '';
                // Ưu tiên <span>, nếu không có thì lấy phần sau dấu ':' (chấp nhận cả ':' và '：')
                const spanTxt = p.querySelector('span')?.textContent?.trim();
                if (spanTxt) return spanTxt;
                const raw = p.textContent.replace(/\u00A0/g, ' ')
                .replace(/：/g, ':');
                return raw.split(':').slice(1).join(':').trim();
            };

            const updatedTextRaw = getTextFromP(pTime);
            console.log('[parseBookFromPage] updatedText raw:', updatedTextRaw);

            // --- PARSE date (cover dd/mm/yyyy, dd-mm-yyyy, yyyy-mm-dd, kèm hh:mm[:ss]) ---
            const updated = (() => {
                const s0 = (updatedTextRaw || '').trim();
                if (!s0) return null;

                // Chuẩn hoá: '-', '.' -> '/', gom khoảng trắng
                const t = s0.replace(/[.\-]/g, '/').replace(/\s+/g, ' ');

                // 1) dd/mm/yyyy [hh:mm[:ss]]
                let m = t.match(
                    /^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/
                );
                if (m) {
                    const [, d, mo, y, hh = '00', mm = '00', ss = '00'] = m;
                    const dt = new Date(+y, +mo - 1, +d, +hh, +mm, +ss);
                    return isNaN(+dt) ? null : dt;
                }

                // 2) yyyy/mm/dd [hh:mm[:ss]] (trường hợp server trả 2025-09-21 ...)
                m = t.match(
                    /^(\d{4})\/(\d{1,2})\/(\d{1,2})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/
                );
                if (m) {
                    const [, y, mo, d, hh = '00', mm = '00', ss = '00'] = m;
                    const dt = new Date(+y, +mo - 1, +d, +hh, +mm, +ss);
                    return isNaN(+dt) ? null : dt;
                }

                // 3) Fallback: bắt cụm dd/mm/yyyy ở bất kỳ đâu
                m = t.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
                if (m) {
                    const [, d, mo, y] = m;
                    const dt = new Date(+y, +mo - 1, +d);
                    return isNaN(+dt) ? null : dt;
                }
                return null;
            })();

            console.log('[parseBookFromPage] updated parsed:', updated);
            const getLinkTextFromP = (p) => p?.querySelector('a')?.textContent.trim() || getTextFromP(p);
            const author = getLinkTextFromP(findP('tac gia'));
            const status = getLinkTextFromP(findP('tinh trang'));
            const pThanks = findP('cam on');
            let thanksCount = 0;
            if (pThanks) {
                // Lấy text trong thẻ span nếu có, không thì lấy text của cả thẻ p
                const thanksRaw = pThanks.querySelector('span')?.textContent || pThanks.textContent;
                thanksCount = parseInt(thanksRaw.replace(/[^0-9]/g, '')) || 0;
            }
            console.log('[DEBUG] Thanks Count Captured:', thanksCount);
            console.log('[parseBookFromPage] author:', author, 'status:', status, 'updated:', updated);

            const stats = {};
            info.querySelectorAll('.book-stats').forEach(span => {
                const icon = span.querySelector('i');
                const raw = (span.querySelector('[data-ready]') || span).textContent.trim();
                if (!icon) return;
                const iconName = icon.classList.contains('material-icons') ? icon.textContent.trim() : icon.className;
                if (iconName === 'visibility') stats.views = parseAbbr(raw);
                else if (iconName === 'star') stats.rating = parseAbbr(raw);
                else if (iconName.includes('fa-comment')) stats.comments = parseAbbr(raw);
            });
            console.log('[parseBookFromPage] stats:', stats);

            let chapters = await fetchAccurateChapterCount(doc, bookId);
            if (chapters === null) { // Fallback về cách cũ nếu API lỗi
                const latestChapterLink = Array.from(info.querySelectorAll('p a')).find(a => a.href.includes('/truyen/') && a.href.includes('/chuong-'));
                if (latestChapterLink) {
                    const chapterText = latestChapterLink.textContent.trim();
                    const chapterMatch = chapterText.match(/chương\s*(\d+)/i) || chapterText.match(/(\d+)/);
                    if (chapterMatch) chapters = parseInt(chapterMatch[1], 10);
                }
            }
            console.log('[parseBookFromPage] chapters:', chapters);

            const genreP =
                  Array.from(doc.querySelectorAll('.book-desc p'))
            .find(p => /thể loại/i.test(p.textContent)) || null;
            const genreLinks = genreP ? Array.from(genreP.querySelectorAll('a')) : [];
            const collections = genreLinks.map(a => a.textContent.trim()).filter(Boolean);
            const tags = collections[1] ? [collections[1]] : [];

            console.log('[parseBookFromPage] collections:', collections, 'tags:', tags);
            const getManagerSlug = (div) => {
                const a = div?.querySelector('.manager-name a[href^="/user/"]');
                if (!a) return null;
                const m = a.getAttribute('href').match(/\/user\/([^/]+)/);
                return m ? decodeURIComponent(m[1]) : null;
            };

            const newFlags = {};
            const managerDivs = doc.querySelectorAll('.book-manager');

            const roleOf = (div) => div?.querySelector('.manager-role')?.textContent.trim();

            const posterDiv = Array.from(managerDivs).find(div => roleOf(div) === 'Người đăng');
            const coManagerDivs = Array.from(managerDivs).filter(div => roleOf(div) === 'Đồng quản lý');

            if (posterDiv && currentUser) {
                const posterSlug = getManagerSlug(posterDiv);
                console.log('[parseBookFromPage] posterSlug:', posterSlug, 'currentUser:', currentUser);
                if (posterSlug && posterSlug === currentUser) {
                    newFlags.poster = true;
                    if (coManagerDivs.length > 0) newFlags.managerOwner = true;
                }
            }

            if (coManagerDivs.length > 0 && currentUser) {
                const coManagerSlugs = coManagerDivs.map(getManagerSlug).filter(Boolean);
                console.log('[parseBookFromPage] coManagerSlugs:', coManagerSlugs);
                if (coManagerSlugs.includes(currentUser) && !newFlags.poster) {
                    newFlags.managerGuest = true;
                }
            }


            newFlags.embedLink = !!Array.from(doc.querySelectorAll('.book-desc p a')).find(a => a.textContent === 'Liên kết nhúng');
            newFlags.embedFile = !newFlags.embedLink;
            console.log('[parseBookFromPage] newFlags:', newFlags);

            const summaryEl = doc.querySelector('.book-desc-detail');
            const summary = summaryEl ? summaryEl.innerText.trim() : '';
            console.log('[parseBookFromPage] summary captured:', summary.substring(0, 100) + '...'); // Log 100 ký tự đầu

            const oldBook = state.cache?.books?.[bookId] || {};
            console.log('[parseBookFromPage] oldBook.flags:', oldBook.flags);

            const result = {
                id: bookId,
                title,
                url: bookUrl,
                coverUrl,
                author,
                status,
                summary,
                statusNorm: norm(status),
                titleNorm: norm(title),
                authorNorm: norm(author),
                tags,
                stats: {
                    ...stats,
                    thanks: thanksCount
                },
                chapters,
                updated,
                updatedISO: updated ? updated.toISOString() : '',
                updatedTs: updated ? +updated : 0,
                updatedText: updated ? fmtDate(updated) : '',
                collectedAt: oldBook.collectedAt || new Date().toISOString(),
                collections,
                flags: { ...oldBook.flags, ...newFlags },
            };
            console.log('[parseBookFromPage] result:', result);
            return result;
        } catch (err) {
            console.error('[WorksManager] parseBookFromPage failed', err);
            return null;
        }
    };


    const parseSummaryFromPage = (doc) => {
        const summaryEl = doc.querySelector('.book-desc-detail');
        return summaryEl ? summaryEl.innerText.trim() : '';
    };

    const handleManualAdd = async () => {
        const url = window.prompt('Nhập URL truyện cần thêm/cập nhật:', '');
        if (!url) return;

        try {
            const parsedUrl = new URL(url);
            if (!ALLOWED_HOSTNAMES.includes(parsedUrl.hostname) || !parsedUrl.pathname.startsWith('/truyen/')) {
                throw new Error('URL không hợp lệ.');
            }
            updateOverlay({ text: 'Đang tải và xử lý truyện...', progress: 50, meta: '' });
            const response = await fetch(parsedUrl.href);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const html = await response.text();
            const doc = new DOMParser().parseFromString(html, 'text/html');
            const bookId = window.bookId || doc.querySelector('input[name="bookId"]')?.value;
            if (!bookId) throw new Error('Không tìm thấy ID truyện.');
            const currentUserSlug = getCurrentUser(doc);
            if (!currentUserSlug) throw new Error('Không xác định được người dùng.');

            state.key = `works:${currentUserSlug}:works:v${STORE_VERSION}`;
            await localforage.ready();
            await loadCache();

            const book = await parseBookFromPage(doc, bookId, parsedUrl.href, state.cache ? state.cache.username : currentUserSlug);
            if (!book) throw new Error('Không thể phân tích thông tin truyện.');
            const userHasRole = book.flags.poster || book.flags.managerOwner || book.flags.managerGuest || book.flags.editorOwner || book.flags.editorGuest;
            if (!userHasRole) throw new Error(`Bạn không có vai trò quản lý nào cho truyện này.`);

            if (!state.cache) {
                state.cache = { books: {}, bookIds: [], version: STORE_VERSION, username: currentUserSlug, mode: 'works' };
            }
            if (!state.cache.books[book.id]) {
                state.cache.bookIds.unshift(book.id);
            }
            state.cache.books[book.id] = book;
            await saveCache(state.cache);
            notify(TEXT.manualAdded);


            if (state.channel) {
                state.channel.postMessage({ origin: ORIGIN_ID, type: 'add', book });
            }
            if (state.filterModal) {
                console.log('[WorksManager] Cửa sổ lọc đang mở, tự động làm mới kết quả.');
                state.filterModal.shadowRoot.querySelector('button[data-action="apply"]').click();
            }

        } catch (err) {
            console.error('[WorksManager] Manual Add failed', err);
            notify(`Lỗi: ${err.message}`, true);
        } finally {
            hideOverlay();
            updateSummary();
        }
    };


    const runFilter = (criteria) => {
        if (!state.cache) return [];
        const toMs = (v) => {
            if (!v) return 0;
            return (v instanceof Date) ? v.getTime() : (Date.parse(v) || 0);
        };
        const dateInputToMs = (s) => s ? Date.parse(s) : 0;
        let list = state.cache.bookIds.map((id) => state.cache.books[id]).filter(Boolean);

        if (criteria.status && criteria.status !== 'all') {
            const target = norm(criteria.status);
            list = list.filter((b) => b.statusNorm === target);
        }
        // Tìm kiếm theo tiêu đề/tác giả
        if (criteria.search) {
            const q = norm(criteria.search);
            list = list.filter((b) =>
                               (b.titleNorm && b.titleNorm.includes(q)) ||
                               (b.authorNorm && b.authorNorm.includes(q))
                              );
        }
        if (criteria.summarySearch) {
            const q = norm(criteria.summarySearch);
            list = list.filter((b) => b.summary && norm(b.summary).includes(q));
        }
        if (criteria.categories && criteria.categories.length) {
            list = list.filter((b) => b.collections && b.collections.some((label) => criteria.categories.includes(label)));
        }

        if (criteria.fromDate) {
            const fromMs = dateInputToMs(criteria.fromDate);
            list = list.filter((b) => !toMs(b.updated) || toMs(b.updated) >= fromMs);
        }
        if (criteria.toDate) {
            const toMsVal = dateInputToMs(criteria.toDate);
            list = list.filter((b) => !toMs(b.updated) || toMs(b.updated) <= toMsVal);
        }

        list = list.slice();
        const sort = criteria.sortBy || 'recent';
        list.sort((a, b) => {
            if (sort === 'recent') return toMs(b.updated) - toMs(a.updated);
            if (sort === 'oldest') return toMs(a.updated) - toMs(b.updated);
            if (sort === 'views') return (b.stats.views || 0) - (a.stats.views || 0);
            if (sort === 'rating') return (b.stats.rating || 0) - (a.stats.rating || 0);
            if (sort === 'comments') return (b.stats.comments || 0) - (a.stats.comments || 0);
            if (sort === 'thanks') return (b.stats?.thanks || 0) - (a.stats?.thanks || 0);
            if (sort === 'title') return a.title.localeCompare(b.title, 'vi');
            return 0;
        });

        return list;
    };

    const buildCheckGroup = (name, options) => {
        if (!options.length) return '<div style="opacity:.6;">Không có dữ liệu</div>';
        return options.map(({ value, label }) => `
            <label style="display:flex;align-items:center;gap:6px;font-size:12px;">
                <input type="checkbox" name="${name}" value="${value}" style="accent-color:#39c5ff;"> ${label}
            </label>
        `).join('');
    };

    const closeFilter = () => {
        if (state.filterModal) {
            state.filterModal.remove();
            state.filterModal = null;
            if (state.panel) state.panel.style.display = '';
        }
    };
    const openFilter = () => {
        if (!state.cache) { notify(TEXT.noCache, true); return; }
        if (state.filterModal) return;
        if (state.panel) state.panel.style.display = 'none';

        const wrap = document.createElement('div');
        wrap.id = 'wd-works-filter-host';
        state.filterModal = wrap;
        const shadow = wrap.attachShadow({ mode: 'open' });

        const books = state.cache.bookIds.map((id) => state.cache.books[id]).filter(Boolean);
        const categories = Array.from(new Set(books.flatMap((b) => b.collections || []))).sort((a, b) => a.localeCompare(b, 'vi'));

        shadow.innerHTML = `
        <style>
            * { box-sizing: border-box; margin: 0; padding: 0; font-family: Segoe UI, sans-serif; color: #fff; }
            .modal-root { position: fixed; inset: 0; background: rgba(7, 12, 18, 0.85); z-index: 99996; display: flex; align-items: center; justify-content: center; }
            .modal-content { background: #111c28; padding: 20px 24px 26px; border-radius: 14px; width: min(900px, 96vw); height: 90vh; display: flex; flex-direction: column; gap: 16px; box-shadow: 0 20px 44px rgba(0,0,0,0.4); }
            #filterForm { flex-shrink: 0; margin-bottom: 10px; }
            label, .group-title { font-size: 12px; display: block; margin-bottom: 4px; }
            input[type="date"], input[type="text"], select {
                width: 100%; padding: 7px 8px; background: #1a2635; border: 1px solid rgba(255, 255, 255, 0.2);
                color: #fff; border-radius: 6px; font-size: 13px;
            }
            .form-row { display:grid; grid-template-columns: repeat(4, 1fr); gap: 12px; }
            .search-row { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
.checkbox-group-body {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
    gap: 6px;
    max-height: 50px; /* Chiều cao cố định gọn gàng */
    overflow-y: auto; /* Hiện thanh cuộn khi quá dài */
    border: 1px solid rgba(255,255,255,0.1);
    padding: 10px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 6px;}
.checkbox-group-body label { flex: 0 0 calc(20% - 10px); min-width: 120px; display:flex; align-items:center; gap:6px; font-size:12px; margin-bottom:0; }
            .results { font-size:12px; display: flex; flex-direction: column; gap: 10px; flex:1; overflow: hidden;min-height:0; }
            #results-container {
    flex: 1;
    overflow-y: auto;
    padding-right: 10px; /* Tạo khoảng trống cho thanh cuộn không đè nội dung */
    margin-bottom: 10px;
}
            .results-body { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

            /* result-item 2 cột + checkbox kế title */
            .result-item {
                display: grid; grid-template-columns: 24px 1fr; gap: 10px; padding: 12px;
                border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; background: rgba(255,255,255,0.04);
                align-items: start;
            }
            .result-item-checkbox { width: 18px; height: 18px; cursor: pointer; accent-color: #39c5ff; margin-top: 2px; }
            .result-item-content { display: flex; flex-direction: column; height: 100%; }
            .result-item-info a { color:#4bffdc; text-decoration:none; font-weight:600; font-size:13px; }
            .result-item-actions { display: flex; justify-content: flex-end; margin-top: auto; padding-top: 8px; }
            .btn-remove { background:rgba(246,78,96,0.2); border:1px solid rgba(246,78,96,0.3); color:#ff7e8e; padding:3px 8px; border-radius:4px; cursor:pointer; font-size:10px; }

            .selection-toolbar {
    display: none;
    align-items: center;
    gap: 10px;
}
.selection-toolbar.active { display: flex; }
.btn-batch-open { background: #4bffdc; color: #0b1220; padding: 3px 10px; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 11px; border: none; }
.btn-deselect { background: rgba(255,255,255,0.1); color: #fff; padding: 3px 10px; border-radius: 4px; cursor: pointer; border: none; font-size: 11px; }
.selection-info { font-size: 12px; color: #39c5ff; font-weight: 600; white-space: nowrap; }
.footer { display:flex; justify-content:flex-end; gap:12px; margin-top: 5px; }
            .btn-apply { background:#39c5ff; color:#0b1220; padding:5px 10px; border-radius:6px; font-weight:600; border:none; cursor:pointer; }
            .btn-close { background:rgba(255,255,255,0.12); color:#fff; padding:5px 10px; border-radius:6px; border:none; cursor:pointer; }
        </style>
        <div class="modal-root">
            <div class="modal-content">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <strong style="font-size:18px;">Lọc và Quản lý Works</strong>
                    <button data-action="close" style="background:none; border:none; font-size:24px; cursor:pointer;">&times;</button>
                </div>
                <form id="filterForm">
                    <div class="form-row">
                        <div><label>Từ ngày</label><input id="filter-from" type="date"></div>
                        <div><label>Đến ngày</label><input id="filter-to" type="date"></div>
                        <div><label>Trạng thái</label><select id="filter-status"><option value="all">Tất cả</option><option value="Còn tiếp">Còn tiếp</option><option value="Tạm ngưng">Tạm ngưng</option></select></div>
                        <div><label>Sắp xếp</label><select id="filter-sortby">
                        <option value="recent">Mới nhất</option>
                        <option value="oldest">Cũ nhất</option>
                        <option value="views">Lượt xem</option>
                        <option value="comments">Bình luận</option>
                        <option value="rating">Rating</option>
                        <option value="thanks">Cảm ơn</option>
                        </select></div>
                    </div>
                    <div class="search-row">
                        <input id="filter-search" type="text" placeholder="Tìm tiêu đề hoặc tác giả...">
                        <input id="filter-summary" type="text" placeholder="Tìm trong nội dung tóm tắt...">
                    </div>
                    <div class="checkbox-group-body">
                        ${buildCheckGroup('category', categories.map(c => ({ value: c, label: c })))}
                    </div>
                </form>
                <div class="footer">
                    <button class="btn-apply" data-action="apply">Lọc dữ liệu</button>
                    <button class="btn-close" data-action="close">Đóng</button>
                </div>
                <div class="results">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; min-height: 25px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 6px;">
        <div id="results-header-text" style="font-weight: bold; color: #ccc; font-size: 12px;">Đang tải...</div>

        <div class="selection-toolbar" id="selection-toolbar">
            <div class="selection-info">Đã chọn: <span id="selected-count">0</span></div>
            <button class="btn-deselect" data-action="deselect-all">Bỏ chọn</button>
            <button class="btn-batch-open" data-action="batch-open">Mở hàng loạt</button>
        </div>
    </div>

    <div id="results-container"></div>
</div>
            </div>
        </div>`;

    const updateSelectionUI = () => {
        const checked = shadow.querySelectorAll('.result-item-checkbox:checked');
        const toolbar = shadow.querySelector('#selection-toolbar');
        const countEl = shadow.querySelector('#selected-count');
        if (toolbar && countEl) {
            if (checked.length > 0) {
                toolbar.classList.add('active');
                countEl.textContent = checked.length;
            } else {
                toolbar.classList.remove('active');
            }
        }
    };

    shadow.addEventListener('click', async (e) => {
        const target = e.target;
        const action = target.dataset.action;

        if (action === 'close') closeFilter();
        if (action === 'apply') {
            const criteria = {
                fromDate: shadow.querySelector('#filter-from').value,
                toDate: shadow.querySelector('#filter-to').value,
                status: shadow.querySelector('#filter-status').value,
                search: shadow.querySelector('#filter-search').value,
                summarySearch: shadow.querySelector('#filter-summary').value,
                sortBy: shadow.querySelector('#filter-sortby').value,
                categories: Array.from(shadow.querySelectorAll('input[name=category]:checked')).map(i => i.value),
            };
            renderResults(shadow, runFilter(criteria));
        }
        if (target.classList.contains('result-item-checkbox')) updateSelectionUI();
        if (action === 'deselect-all') {
            shadow.querySelectorAll('.result-item-checkbox').forEach(cb => cb.checked = false);
            updateSelectionUI();
        }
        if (action === 'batch-open') {
            const checked = Array.from(shadow.querySelectorAll('.result-item-checkbox:checked'));
            const urls = checked.map(cb => cb.dataset.url);
            if (!urls.length) return;
            if (urls.length > 5 && !window.confirm(`Bạn sắp mở ${urls.length} tab mới. Có thể gây lag máy, tiếp tục?`)) return;
            urls.forEach(url => GM_openInTab(url, { active: false, insert: true }));
        }
        if (action === 'manual-remove') {
            await handleManualRemove(target.dataset.id);
            shadow.querySelector('button[data-action="apply"]').click();
        }
    });

    document.body.appendChild(wrap);
    shadow.querySelector('button[data-action="apply"]').click();
};

    const renderResults = (shadow, results) => {
        const container = shadow.querySelector('#results-container');
        const headerTextEl = shadow.querySelector('#results-header-text');

        let headerText = `Tìm thấy ${fmtNum(results.length)} truyện.`;
        let displayed = results;

        if (results.length > FILTER_RESULT_LIMIT) {
            headerText = `Tìm thấy ${fmtNum(results.length)} (Hiện ${FILTER_RESULT_LIMIT})`;
            displayed = results.slice(0, FILTER_RESULT_LIMIT);
        }

        if (headerTextEl) headerTextEl.textContent = headerText;

        const holder = document.createElement('div');
        holder.className = 'results-body';

        displayed.forEach(book => {
            const stats = book.stats || {};
            const item = document.createElement('div');
            item.className = 'result-item';

            // Khôi phục đầy đủ các dòng stats
            const lines = [];
            lines.push(`${book.author} • ${book.status} • 📅 ${book.updatedText || '—'} • 📑 ${fmtNum(book.chapters || 0)} chương`);
            lines.push(`👁️ ${fmtNum(stats.views || 0)} • ⭐ ${fmtNum(stats.rating || 0)} • 💬 ${fmtNum(stats.comments || 0)} • ❤️ ${fmtNum(stats.thanks || 0)}`);

            item.innerHTML = `
                <input type="checkbox" class="result-item-checkbox" data-url="${book.url}" data-id="${book.id}">
                <div class="result-item-content">
                    <div class="result-item-info">
                        <a href="${book.url}" target="_blank" style="color:#4bffdc; text-decoration:none; font-weight:600; font-size:13px;">${book.title}</a>
                        <div style="font-size:11px; color:#ccc; margin-top:4px; line-height:1.5;">
                            ${lines.join('<br>')}
                        </div>
                        ${book.collections && book.collections.length ? `<div style="font-size: 10px; margin-top:4px; color:#888;">Thể loại: ${book.collections.join(', ')}</div>` : ''}
                    </div>
                    <div class="result-item-actions">
                        <button class="btn-remove" data-action="manual-remove" data-id="${book.id}">Xóa cache</button>
                    </div>
                </div>`;
            holder.appendChild(item);
        });

      container.innerHTML = '';
      container.appendChild(holder);

      // Reset toolbar về trạng thái ẩn mỗi khi lọc mới
      const toolbar = shadow.querySelector('#selection-toolbar');
      if (toolbar) toolbar.classList.remove('active');
  };

    const readMaxPages = (doc) => {
        const lastPageLink = doc.querySelector('.pagination li:last-child a[href*="start="]');
        if (lastPageLink) {
            try {
                const start = new URL(lastPageLink.href, window.location.origin).searchParams.get('start');
                return (parseInt(start, 10) / 10) + 1;
            } catch (e) { /* ignore */ }
        }
        // Nếu không có nút trang cuối, kiểm tra xem có truyện nào không
        return doc.querySelector('.book-info') ? 1 : 0;
    };

 // Thay thế hàm handleSync và các hàm liên quan trong script của bạn bằng đoạn này:

    const handleSync = async () => {
        if (state.syncing) { notify(TEXT.syncRunning, true); return; }
        const options = await askSyncOptions();
        if (!options) return;

        setTimeout(async () => {
            const started = Date.now();
            state.syncing = true;
            state.abort = false;

            // Chế độ đồng bộ
            const isFullSync = options.mode.startsWith('full');
            // Khởi tạo/Lấy cache cũ
            let aggregated = (state.cache) ? state.cache : { books: {}, bookIds: [], username: state.username, version: STORE_VERSION };

            try {
                // GIAI ĐOẠN 1: LẤY TẤT CẢ DANH SÁCH TỪ TẤT CẢ CÁC TRANG
                updateOverlay({ text: 'Giai đoạn 1: Lấy danh sách truyện từ các trang', progress: 0 });

                const firstDoc = await fetchDocument(0);
                const firstData = extractFromDocument(firstDoc);
                if (!firstData.list.length) throw new Error('Không đọc được danh sách works.');

                // Cập nhật trang đầu tiên
                firstData.list.forEach(b => {
                    if (!aggregated.books[b.id]) {
                        aggregated.bookIds.push(b.id);
                    }
                    aggregated.books[b.id] = b; // Ghi đè thông tin cơ bản mới nhất
                });

                let pageSize = firstData.pageSize || 10;
                let maxPages = readMaxPages(firstDoc);

                for (let p = 2; p <= maxPages; p++) {
                    if (state.abort) throw new Error(TEXT.syncAbort);
                    await sleep(options.delay);
                    const doc = await fetchDocument((p - 1) * pageSize);
                    extractFromDocument(doc).list.forEach(b => {
                        if (!aggregated.books[b.id]) {
                            aggregated.bookIds.push(b.id);
                        }
                        aggregated.books[b.id] = b;
                    });
                    updateOverlay({ progress: (p / maxPages) * 30, meta: `Đã quét ${p}/${maxPages} trang danh sách` });
                }

                // GIAI ĐOẠN 2: LỌC TRẠNG THÁI VÀ CẬP NHẬT CHI TIẾT (Tóm tắt + Stats)
                // Chỉ xét: Còn tiếp, Tạm ngừng, Chưa xác minh
                const allowedStatus = ['con tiep', 'tam ngung', 'chua xac minh'];
                const targetIds = aggregated.bookIds.filter(id => {
                    const status = norm(aggregated.books[id].status);
                    return allowedStatus.includes(status);
                });

                if (targetIds.length > 0) {
                    updateOverlay({ text: `Giai đoạn 2: Tải chi tiết cho ${targetIds.length} truyện`, progress: 30 });

                    let completed = 0;
                    for (const id of targetIds) {
                        if (state.abort) throw new Error(TEXT.syncAbort);

                        const book = aggregated.books[id];
                        try {
                            // Truy cập trực tiếp trang chi tiết truyện
                            const bookDoc = await fetchDocument(0, { overrideUrl: book.url });

                            // Sử dụng hàm parseBookFromPage có sẵn của bạn để lấy Tóm tắt + Full Stats
                            const detailedInfo = await parseBookFromPage(bookDoc, id, book.url, state.username);

                            if (detailedInfo) {
                                // Cập nhật lại toàn bộ dữ liệu 
                                aggregated.books[id] = { ...aggregated.books[id], ...detailedInfo };
                            }
                        } catch (e) {
                            console.warn(`Lỗi khi tải chi tiết truyện ${id}:`, e);
                        }

                        completed++;
                        const subProgress = 30 + (completed / targetIds.length) * 70;
                        const elapsed = Date.now() - started;
                        const eta = (elapsed / completed) * (targetIds.length - completed);

                        updateOverlay({
                            progress: subProgress,
                            meta: `Đang xử lý: ${completed}/${targetIds.length} - ETA: ${fmtDuration(eta)}`
                        });

                        // Delay để tránh bị Cloudflare chặn
                        await sleep(options.delay);

                        // Lưu cache tạm thời sau mỗi 5 truyện để đề phòng crash
                        if (completed % 5 === 0) await saveCache(aggregated);
                    }
                }

                const duration = Date.now() - started;
                aggregated.syncedAt = new Date().toISOString();
                aggregated.durationMs = duration;

                await saveCache(aggregated);
                notify(TEXT.syncDone);

            } catch (err) {
                console.error(err);
                notify('Đồng bộ thất bại: ' + err.message, true);
            } finally {
                state.syncing = false;
                hideOverlay();
                updateSummary();
            }
        }, 0);
    };

    const analyzeFilterTasks = async (started) => {
        updateOverlay({ text: 'Giai đoạn 2/3: Phân tích bộ lọc', subTask: 'Lấy danh sách bộ lọc mới nhất...', progress: 33 });

        const cleanDoc = await fetchDocument(0);
        const anchors = Array.from(cleanDoc.querySelectorAll('#ddFilter a'));
        const handlers = { bc: 'Thể loại', ba: 'Vai trò', be: 'Vai trò', bt: 'Thuộc tính', bs: 'Trạng thái' };
        const tasks = [];

        const validAnchors = anchors.filter(a => {
            const h = a.getAttribute('href');
            return h && h !== '#!' && a.textContent.trim() !== 'Tất cả';
        });

        let analyzedCount = 0;
        for (const anchor of validAnchors) {
            if (state.abort) throw new Error(TEXT.syncAbort);
            const label = anchor.textContent.trim();
            const href = anchor.getAttribute('href');

            analyzedCount++;
            const elapsed = Date.now() - started;
            const etaMs = analyzedCount > 0 ? (elapsed / analyzedCount) * (validAnchors.length - analyzedCount) : 0;
            updateOverlay({ subTask: `Phân tích: ${label} – ETA: ${fmtDuration(etaMs)}` });

            try {
                const url = new URL(href, window.location.origin);
                const entries = Array.from(url.searchParams.entries());
                const taskEntry = entries.find(([k]) => handlers[k]);
                if (!taskEntry) continue;

                const [key, value] = taskEntry;
                const filterDoc = await fetchDocument(0, { [key]: value });
                const total = readTotal(filterDoc);
                const pages = readMaxPages(filterDoc);
                tasks.push({ label, key, value, group: handlers[key], params: { [key]: value }, total: total || 0, pages });
                await sleep(500);
            } catch (e) { console.warn('Lỗi phân tích túi lọc:', label); }
        }
        return tasks;
    };

 const applyTask = (book, task) => {
    if (!book) return;
    const { flags, collections } = book;
    switch (task.key) {
        case 'bc': addUnique(collections, task.label); break;
        case 'ba':
            if (task.value === '1') { // Đồng quản lý - chủ
                flags.managerOwner = true;
                flags.poster = true; // Là trường hợp đặc biệt của "Tôi là người đăng"
            } else if (task.value === '3') { // Tôi là người đăng
                flags.poster = true;
            } else if (task.value === '2') { // Đồng quản lý - khách
                flags.managerGuest = true;
            }
            break;
        case 'be':
            if (task.value === '1') { // Biên tập - chủ
                flags.editorOwner = true;
                flags.poster = true; // Cũng là trường hợp đặc biệt của "Tôi là người đăng"
            } else if (task.value === '2') { // Biên tập - khách
                flags.editorGuest = true;
            }
            break;
        case 'bt':
            if (task.value === '1') flags.embedLink = true; else if (task.value === '2') flags.embedFile = true; break;
    }
};

const collectSummaries = async (aggregated, threads, delay, started) => {
    updateOverlay({ text: 'Giai đoạn 3/3: Tải tóm tắt', subTask: 'Chuẩn bị...', progress: 85 });

    // Lọc danh sách cần fetch:
    // 1. Chưa có tóm tắt
    // 2. Trạng thái KHÔNG PHẢI là "Hoàn thành"
    const bookIdsToFetch = aggregated.bookIds.filter(id => {
        const book = aggregated.books[id];
        const status = (book.statusNorm || '').trim().toLowerCase();

        // Danh sách trạng thái được phép tải tóm tắt (đã chuẩn hóa không dấu)
        const allowedStatus = ['con tiep', 'tam ngung', 'chua xac minh'];

        // Điều kiện: Chưa có summary VÀ nằm trong danh sách cho phép
        return !book.summary && allowedStatus.includes(status);
    });

    if (bookIdsToFetch.length === 0) {
        updateOverlay({ meta: 'Không có truyện mới cần tải tóm tắt (hoặc các truyện đều đã Hoàn thành).' });
        await sleep(1500);
        return;
    }

    let completedCount = 0;
    const totalToFetch = bookIdsToFetch.length;
    const baseProgress = 85;

    const worker = async (queue) => {
        for (const bookId of queue) {
            if (state.abort) break;
            const book = aggregated.books[bookId];
            if (!book || !book.url) continue;

            try {
                const bookDoc = await fetchDocument(0, { overrideUrl: book.url });
                const summary = parseSummaryFromPage(bookDoc);

                if (summary) {
                    aggregated.books[bookId].summary = summary;
                    // Lưu cache sau mỗi lần tải thành công để bảo toàn dữ liệu
                    await saveCache(state.cache);
                }
            } catch (err) {
                console.error(`[WorksManager] Lỗi khi tải tóm tắt cho ${book.title}:`, err);
            } finally {
                completedCount++;
                const progress = baseProgress + (completedCount / totalToFetch) * 15;
                const elapsed = Date.now() - started;
                const timePerItem = elapsed / (completedCount || 1);
                const etaMs = timePerItem * (totalToFetch - completedCount);
                const etaString = etaMs > 1000 ? ` – ETA: ${fmtDuration(etaMs)}` : '';

                updateOverlay({
                    progress,
                    meta: `Đang tải tóm tắt: ${completedCount}/${totalToFetch}${etaString}`
                    });
                    await sleep(delay);
                }
            }
        };

       const queues = Array.from({ length: threads }, () => []);
       bookIdsToFetch.forEach((id, index) => queues[index % threads].push(id));

       const workers = queues.map(queue => worker(queue));
       await Promise.all(workers);
   };


const collectAdditionalMetadata = async (aggregated, started) => {
        // Reset flags và collections
        Object.values(aggregated.books).forEach(book => {
            book.flags = { poster: false, managerOwner: false, managerGuest: false, editorOwner: false, editorGuest: false, embedLink: false, embedFile: false, duplicate: false };
            book.collections = [];
        });

        const allTasks = await analyzeFilterTasks(document, started);
        const taskGroups = allTasks.reduce((acc, task) => {
            if (!acc[task.group]) acc[task.group] = [];
            acc[task.group].push(task);
            return acc;
        }, {});

        const totalGroups = Object.keys(taskGroups).length;
        let groupIndex = 0;

        for (const groupName in taskGroups) {
            groupIndex++;
            const progressBase = 33 + (66 * (groupIndex - 1) / totalGroups);
            updateOverlay({ text: `Giai đoạn 2/3: Thu thập ${groupName}`, subTask: 'Bắt đầu...', progress: progressBase });

            const groupTasks = taskGroups[groupName];

            for (const [i, task] of groupTasks.entries()) {
                if (state.abort) throw new Error(TEXT.syncAbort);

                // NẾU LÀ NHÓM HOÀN THÀNH -> CHỈ CẦN QUÉT ĐỂ BIẾT TRẠNG THÁI, KHÔNG CẦN XỬ LÝ SÂU
                // Điều này giúp tránh lỗi "ko hoạt động" khi danh sách có đủ loại truyện

                const elapsed = Date.now() - started;
                const etaString = `– ETA: ${fmtDuration((elapsed / (i + 1)) * (groupTasks.length - (i + 1)))}`;
                updateOverlay({ subTask: `Đang quét: ${task.label} (${task.total} truyện) ${etaString}` });

                const ids = await fetchIdsForTask(task);
                ids.forEach(id => {
                    const book = aggregated.books[id];
                    if (book) {
                        applyTask(book, task);
                    }
                });
            }
            updateOverlay({ progress: 33 + (66 * groupIndex / totalGroups) });
        }
    };



const initializeStoryPage = async () => {
    const currentUserSlug = getCurrentUser(document);
    if (!currentUserSlug) return;
    const bookId = window.bookId || document.querySelector('input[name="bookId"]')?.value;
    if (!bookId) return;

    state.key = `works:${currentUserSlug}:works:v${STORE_VERSION}`;
    localforage.config(STORE_CFG);
    await localforage.ready();
    await loadCache();

    if (!state.cache || !state.cache.books || !state.cache.books[bookId]) return;

    const updatedBook = await parseBookFromPage(document, bookId, window.location.href.split('#')[0], state.cache.username);

    if (updatedBook) {
        state.cache.books[bookId] = updatedBook;
        await saveCache(state.cache);
        notify(`Đã cập nhật "${updatedBook.title}" từ trang truyện.`);
        // Gửi thông báo cập nhật cho các tab khác
        const channelName = `${BROADCAST_PREFIX}${state.key}`;
        try {
            const channel = new BroadcastChannel(channelName);
            channel.postMessage({ origin: ORIGIN_ID, type: 'update', book: updatedBook });
            channel.close();
        } catch(e) {}
    }
};

const initializeWorksPage = async () => {
    const context = detectContext();
    if (!context) return;
    state.username = context.username;
    state.mode = context.mode;
    state.basePath = context.basePath;
    state.key = `works:${state.username}:${state.mode}:v${STORE_VERSION}`;

    localforage.config(STORE_CFG);
    await localforage.ready();
    ensurePanel();
    await loadCache();
    updateSummary();

    // Thiết lập kênh liên lạc
    state.channelName = `${BROADCAST_PREFIX}${state.key}`;
    try {
        state.channel = new BroadcastChannel(state.channelName);
        state.channel.onmessage = (event) => {
            if (event.data.origin === ORIGIN_ID) return; // Bỏ qua tin nhắn từ chính mình

            const { type, book, bookId, title } = event.data;
            let message = '';
            let needsUiUpdate = false;

            if (type === 'update' && book && state.cache?.books[book.id]) {
                state.cache.books[book.id] = book;
                message = `Đã nhận cập nhật cho: "${book.title}"`;
                needsUiUpdate = true;
            } else if (type === 'add' && book && state.cache) {
                if (!state.cache.books[book.id]) {
                    state.cache.bookIds.unshift(book.id);
                }
                state.cache.books[book.id] = book;
                message = `Đã nhận truyện mới: "${book.title}"`;
                needsUiUpdate = true;
            } else if (type === 'remove' && bookId && state.cache?.books[bookId]) {
                state.cache.bookIds = state.cache.bookIds.filter(id => id !== bookId);
                delete state.cache.books[bookId];
                message = `Đã xóa truyện: "${title}"`;
                needsUiUpdate = true;
            }

            if (needsUiUpdate) {
                console.log(`[WorksManager] Broadcast received: ${message}`);
                setMessage(message);
                setTimeout(() => { if (panelMessage().textContent === message) setMessage(''); }, 5000);

                updateSummary();

                // LOGIC: LƯU VÀ PHỤC HỒI VỊ TRÍ CUỘN
                if (state.filterModal) {
                    // Tìm đến vùng chứa kết quả có thể cuộn được
                    const resultsBody = state.filterModal.shadowRoot.querySelector('.results-body');

                    // 1. Lưu lại vị trí cuộn hiện tại (nếu có)
                    const scrollTop = resultsBody ? resultsBody.scrollTop : 0;

                    // 2. Kích hoạt việc lọc lại như cũ
                    state.filterModal.shadowRoot.querySelector('button[data-action="apply"]').click();

                    // 3. Khôi phục lại vị trí cuộn sau một khoảng trễ nhỏ
                    // (cần trễ một chút để DOM có thời gian cập nhật kết quả mới)
                    setTimeout(() => {
                        const newResultsBody = state.filterModal.shadowRoot.querySelector('.results-body');
                        if (newResultsBody) {
                            newResultsBody.scrollTop = scrollTop;
                        }
                    }, 100); // 100ms là đủ để giao diện cập nhật
                }
            }
        };
    } catch (e) {
        if (!broadcastWarned) {
            console.warn('[WorksManager] BroadcastChannel không được hỗ trợ. Đồng bộ thời gian thực sẽ không hoạt động.');
            broadcastWarned = true;
        }
    }

    GM_registerMenuCommand('Đồng bộ works', handleSync);
    GM_registerMenuCommand('Xuất dữ liệu works', handleExport);
    GM_registerMenuCommand('Nhập dữ liệu works', handleImport);
    GM_registerMenuCommand('Lọc works', openFilter);
    if (!state.cache) notify(TEXT.needSync);
};

const bootstrap = async () => {
    const path = window.location.pathname;
    if (path.includes('/user/') && path.includes('/works')) {
        await initializeWorksPage();
    } else if (path.startsWith('/truyen/')) {
        await initializeStoryPage();
    }
};

if (document.readyState === 'loading') {
    window.addEventListener('DOMContentLoaded', () => {
        bootstrap().catch((err) => console.error('[WorksManager] init', err));
    }, { once: true });
} else {
    bootstrap().catch((err) => console.error('[WorksManager] init', err));
}
})();
